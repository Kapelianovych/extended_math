import 'dart:math';

import 'package:quiver/core.dart';

import '../../../general_algebraic_systems/number/base/number.dart';
import '../../../general_algebraic_systems/number/exceptions/division_by_zero_exception.dart';
import '../../exceptions/vector_exception.dart';
import '../base/tensor_base.dart';
import '../tensor2/matrix.dart';
import '../tensor2/square_matrix.dart';

/// Class for work with vectors
class Vector extends TensorBase {
  /// Inits data for vector
  const Vector(this._data) : super(1);

  /// Generates vector with [length] and values generated by [generator]
  factory Vector.generate(int length, num Function(num number) generator) =>
      TensorBase.generate([length], generator).toVector();

  /// Data for vector
  final List<num> _data;

  @override
  List<num> get data => _data.toList();

  @override
  List<int> get shape => [itemsCount];

  @override
  int get itemsCount => data.length;

  /// Gets length of this vector
  num get length => euclideanNorm();

  /// Gets number at specified [index]
  ///
  /// [index] is in range from 1 to end inclusively.
  num itemAt(int index) => data[index - 1];

  /// Inserts item to specified [position]
  ///
  /// [position] may be in range from 1 to end inclusively.
  /// If [replace] equals to `true`, old number is replaced by [item],
  /// otherwise [item] sets to specified position and width of [Vector]
  /// is growth by one.
  /// In order to insert [item] to end of [Vector] set position to
  /// **length + 1** or use [add] method:
  /// ```dart
  /// final v = Vector(<num>[1, 2, 3]);
  /// v.insert(4, v.data.length + 1);
  /// // or
  /// v.add(4);
  /// print(v); // [1, 2, 3, 4]
  /// ```
  void insert(num item, {int position = 1, bool replace = true}) =>
      replace ? _data[position - 1] = item : _data.insert(position - 1, item);

  /// Sets item to end of this [Vector]
  void add(num item) => _data.add(item);

  /// Gets norm of vector alse known as vector's length
  ///
  /// [p] should have only integer value, if not - any fractional digits will
  /// be discarded.
  num norm(double p) {
    final n = p.truncateToDouble();
    if (n <= 0) {
      throw VectorException('P must be greater or equal to 1! Given $p.');
    } else if (n.isInfinite) {
      var res = itemAt(1);
      for (final i in data) {
        if (res < i) {
          res = i;
        }
      }
      return res;
    } else {
      var sum = 0.0;
      for (final item in data) {
        sum += pow(item, n);
      }
      return pow(sum, 1 / n);
    }
  }

  /// Gets Euclidean norm
  num euclideanNorm() => norm(2);

  /// Gets the norm where p is infinite
  num maxNorm() => norm(double.infinity);

  /// Multiply this vector by [vector] using dot product algorithm
  num dot(Vector vector) =>
      toMatrixRow().matrixProduct(vector.toMatrixColumn()).itemAt(1, 1);

  /// Converts this vector to matrix with one column
  Matrix toMatrixColumn() {
    final matrix = data.map((value) => <num>[value]).toList();
    return Matrix(matrix);
  }

  /// Convert this vector to martix with one row
  Matrix toMatrixRow() => Matrix(<List<num>>[data]);

  /// Gets cross product of this vector and another [vector]
  ///
  /// Only suited for three-dimensional Euclidean space.
  /// [itemsCount] of both vectors must be equal to 3.
  Vector cross(Vector vector) {
    if (itemsCount == 3 && vector.itemsCount == 3) {
      final v = <num>[];
      for (var i = 1; i <= 3; i++) {
        final m = SquareMatrix(<List<num>>[
          <num>[1, 1, 1],
          data,
          vector.data
        ]);
        m
          ..removeRow(1)
          ..removeColumn(i);
        v.add(m.determinant());
      }
      return Vector(v);
    } else {
      throw VectorException(
          'Vectors should be in three-dimensional Euclidean space.'
          'Found $itemsCount and ${vector.itemsCount}');
    }
  }

  /// Get angle between this vector and another [vector]
  ///
  /// Dafault unit for measuring angle is `radian`.
  /// If [degrees] is true - result will have the degrees unit.
  double angleBetween(Vector vector, {bool degrees = false}) {
    final dotProduct = dot(vector);
    final magnitudes = euclideanNorm() * vector.euclideanNorm();
    if (degrees == false) {
      return acos(dotProduct / magnitudes);
    } else {
      // Cast from radians to degrees
      // 1 rad = 57.295779513 degrees.
      return acos(dotProduct / magnitudes) * 57.295779513;
    }
  }

  /// Gets subvector from this [Vector]
  ///
  /// [start] and [end] may be in range from 1 to end inclusively.
  Vector subvector(int start, [int? end]) =>
      Vector(data.sublist(start - 1, end != null ? end : null));

  /// Gets Hadamard product of vectors
  Vector hadamard(Vector vector) {
    final data = <num>[];
    for (var i = 1; i <= itemsCount; i++) {
      data.add(itemAt(i) * vector.itemAt(i));
    }
    return Vector(data);
  }

  /// Checks if vector is unit vector
  bool isUnit() => euclideanNorm() == 1;

  /// Checks if this vector and [vector] are orthogonal to each other
  bool isOrthogonalTo(Vector vector) => dot(vector) == 0;

  /// Checks if this vector and [vector] are orthonormal
  bool isOrthonormalWith(Vector vector) =>
      isOrthogonalTo(vector) && isUnit() && vector.isUnit();

  @override
  Vector operator *(Object other) {
    var v = Vector([]);
    if (other is num) {
      v = map((v) => v * other);
    } else if (other is Vector) {
      v = hadamard(other);
    } else if (other is Number) {
      v = map((v) => v * other.toDouble());
    }
    return v;
  }

  @override
  Vector operator /(Object other) {
    var v = Vector([]);
    if (other is num) {
      if (other == 0) {
        throw DivisionByZeroException();
      }
      v = this * (1 / other);
    } else if (other is Number) {
      if (other.toDouble() == 0) {
        throw DivisionByZeroException();
      }
      v = this * (1 / other.toDouble());
    }
    return v;
  }

  @override
  Vector operator -() => map((v) => -v);

  /// Gets item of this [Vector] at the specified [index]
  ///
  /// [index] starts from `0` to `length - 1`. The same range have
  /// core [List].
  num operator [](int index) => data[index];

  /// Sets [value] to this [Vector] at the specified [index]
  ///
  /// [index] starts from `0` to `length - 1`. The same range have
  /// core [List].
  void operator []=(int index, num value) => _data[index] = value;

  @override
  Vector operator +(Vector other) {
    if (itemsCount == other.itemsCount) {
      final tmpData = <num>[];
      for (var i = 1; i <= itemsCount; i++) {
        tmpData.add(itemAt(i) + other.itemAt(i));
      }
      return Vector(tmpData);
    } else {
      throw VectorException('Count of vector\'s numbers isn\'t equal!');
    }
  }

  @override
  Vector operator -(Vector other) => this + -other;

  @override
  Vector map(num Function(num number) f) => Vector(data.map(f).toList());

  @override
  num reduce(num Function(num prev, num next) f) => data.reduce(f);

  @override
  bool every(bool Function(num number) f) => data.every(f);

  @override
  bool any(bool Function(num number) f) => data.any(f);

  @override
  List<num> toList() => data;

  @override
  bool operator ==(Object other) =>
      other is Vector && hashCode == other.hashCode;

  @override
  int get hashCode => hashObjects(data);

  @override
  Vector copy() => Vector(data);

  @override
  String toString() => '$data';
}
