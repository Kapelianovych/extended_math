import 'package:quiver/core.dart';

import '../../general_algebraic_systems/number/base/number.dart';
import '../../general_algebraic_systems/number/exceptions/division_by_zero_exception.dart';
import 'base/tensor_base.dart';
import 'tensor2/matrix.dart';

/// Class for work with 3 dimensional tensor
class Tensor3 extends TensorBase {
  /// Creates [Tensor3] with data
  Tensor3(this._data) : super(3);

  /// Generates [Tensor3] with [width], [length] and [depth] and values generated by [generator]
  factory Tensor3.generate(
          int width, int length, int depth, num generator(num number)) =>
      TensorBase.generate(
              <String, int>{'width': width, 'length': length, 'depth': depth},
              generator)
          .toTensor3();

  List<List<List<num>>> _data;

  /// Gets width (columns) of this tensor
  int get width => _data[0].length;

  /// Gets length (rows) of this tensor
  int get length => _data.length;

  /// Gets depth of this tensor
  int get depth => _data[0][0].length;

  @override
  int get itemsCount => width * length * depth;

  @override
  List<List<List<num>>> get data =>
      _data.map((r) => r.map((c) => c.toList()).toList()).toList();

  @override
  Map<String, int> get shape =>
      <String, int>{'width': width, 'length': length, 'depth': depth};

  /// Gets two dimensional matrix in specified depth position
  ///
  /// [depthPosition] may be in range from 1 to end inclusively.
  Matrix matrixAt(int depthPosition) {
    final data = <List<num>>[];
    for (var row in _data) {
      data.add(Matrix(row).columnAt(depthPosition));
    }
    return Matrix(data);
  }

  @override
  Tensor3 map(num f(num number)) => Tensor3(
      data.map((r) => r.map((c) => c.map(f).toList()).toList()).toList());

  @override
  num reduce(num f(num prev, num next)) {
    var list = <num>[];
    for (var r in data) {
      for (var c in r) {
        list = list.followedBy(c).toList();
      }
    }
    return list.reduce(f);
  }

  @override
  bool every(bool f(num number)) {
    var list = <num>[];
    for (var r in data) {
      for (var c in r) {
        list = list.followedBy(c).toList();
      }
    }
    return list.every(f);
  }

  @override
  bool any(bool f(num number)) {
    var list = <num>[];
    for (var r in data) {
      for (var c in r) {
        list = list.followedBy(c).toList();
      }
    }
    return list.any(f);
  }

  /// Gets item of this tensor from specific position
  ///
  /// - `length` -> row
  /// - `width` -> column
  /// - `depth` -> z axis
  ///
  /// All positions may be in range from 1 to end inclusively.
  num itemAt(int length, int width, int depth) =>
      data[length - 1][width - 1][depth - 1];

  /// Sets [value] to this tensor at specific position
  ///
  /// - `length` -> row
  /// - `width` -> column
  /// - `depth` -> z axis
  ///
  /// All position may be in range from 1 to end inclusively.
  num setItem(int length, int width, int depth, num value) =>
      data[length - 1][width - 1][depth - 1] = value;

  /// Add values of [other] to corresponding values of this tensor
  ///
  /// The tensors should be of the same dimension.
  @override
  Tensor3 operator +(Tensor3 other) {
    final t3 = copy();
    for (var l = 1; l <= length; l++) {
      for (var w = 1; w <= width; w++) {
        for (var d = 1; d <= depth; d++) {
          t3.setItem(l, w, d, t3.itemAt(l, w, d) + other.itemAt(l, w, d));
        }
      }
    }
    return t3;
  }

  /// Subtract values of [other] from corresponding values of this tensor
  ///
  /// The tensors should be of the same dimension.
  @override
  Tensor3 operator -(Tensor3 other) => this + -other;

  @override
  Tensor3 operator -() => map((v) => -v);

  /// Multiply this tensor by [other]
  ///
  /// [other] may be one of three types:
  ///     1. num (and subclasses)
  ///     2. Tensor3 (and subclasses)
  ///     3. Number (and subclasses)
  ///
  /// Otherwise returns `null`.
  @override
  Tensor3 operator *(Object other) {
    Tensor3 m;
    if (other is num) {
      m = copy().map((v) => v * other);
    } else if (other is Tensor3) {
      final t3 = copy();
      for (var l = 1; l <= length; l++) {
        for (var w = 1; w <= width; w++) {
          for (var d = 1; d <= depth; d++) {
            t3.setItem(l, w, d, t3.itemAt(l, w, d) * other.itemAt(l, w, d));
          }
        }
      }
      m = t3;
    } else if (other is Number) {
      m = copy().map((v) => v * other.data);
    }
    return m;
  }

  /// Divide this tensor by number of by [other]
  @override
  Tensor3 operator /(Object other) {
    Tensor3 m;
    if (other is num) {
      if (other == 0) {
        throw DivisionByZeroException();
      }
      m = this * (1 / other);
    } else if (other is Number) {
      if (other.data == 0) {
        throw DivisionByZeroException();
      }
      m = this * (1 / other.data);
    }
    return m;
  }

  @override
  bool operator ==(Object other) =>
      other is Tensor3 && hashCode == other.hashCode;

  @override
  int get hashCode => hashObjects(_data);

  @override
  List<num> toList() {
    var list = <num>[];
    for (var length in data) {
      for (var width in length) {
        list = list.followedBy(width).toList();
      }
    }
    return list;
  }

  @override
  Tensor3 copy() {
    final data =
        _data.map((row) => row.map((z) => z.toList()).toList()).toList();
    return Tensor3(data);
  }

  @override
  String toString() => '$_data';
}
